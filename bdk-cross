#!/bin/sh

set -e

# Enhanced spinner function
run_with_spinner() {
  local cmd="$1"
  local label="${2:-Processing}"
  local success_msg="${3:-Done!}"
  local failure_msg="${4:-Failed!}"

  bash -c "$cmd" > /dev/null 2>&1 &
  local pid=$!

  local spin='-\|/'
  local i=0
  while kill -0 $pid 2>/dev/null; do
    i=$(( (i+1) %4 ))
    printf "\r$label ${spin:$i:1}"
    sleep 0.1
  done

  wait $pid
  local status=$?

  if [ $status -eq 0 ]; then
    printf "\r$label... $success_msg\n"
    return 0
  else
    printf "\r$label... $failure_msg\n"
    return 1
  fi
}

# Function to parse GitHub release URL
parse_github_release_url() {
    local url="$1"

    # Extract owner, repo, and tag from URL
    if [[ $url =~ https://github\.com/([^/]+)/([^/]+)/releases/tag/(.+) ]]; then
        local owner="${BASH_REMATCH[1]}"
        local repo="${BASH_REMATCH[2]}"
        local tag="${BASH_REMATCH[3]}"

        # Check if release exists using GitHub API
        local api_url="https://api.github.com/repos/$owner/$repo/releases/tags/$tag"
        local status_code
        status_code=$(curl -s -o /dev/null -w "%{http_code}" "$api_url")

        if [[ "$status_code" -eq 200 ]]; then
            echo "$owner:$repo:$tag"
        elif [[ "$status_code" -eq 404 ]]; then
            echo "‚ùå Invalid GitHub release URL format. Release '$tag' not found for $repo"
            exit 0
        else
            return 0
        fi
    else
        echo "Invalid GitHub release URL format"
        return 1
    fi
}


# Function to download source from GitHub release
download_source_from_release() {
    local owner="$1"
    local repo="$2"
    local tag="$3"
    local target_dir="$4"
    
    echo "üì• Downloading source assets from GitHub release..."
    
    # Create target directory
    mkdir -p "$target_dir"
    # make sure the directory is empty
    rm -rf "$target_dir"/* "$target_dir"/.[!.]* "$target_dir"/..?*
    cd "$target_dir" || return 1
    
    local zip_file="$tag.zip"
    local expected_dir="$repo"  # final renamed folder
    
    # Cleanup old files/folders if they exist
    [ -f "$zip_file" ] && rm -f "$zip_file"
    [ -d "$expected_dir" ] && rm -rf "$expected_dir"
    local old_extracted=$(find . -maxdepth 1 -type d -name "*$tag" ! -name "." ! -name ".." | head -1)
    if [ -n "$old_extracted" ] && [ "$old_extracted" != "." ] && [ "$old_extracted" != ".." ]; then
        rm -rf "$old_extracted"
    fi
    
    # Download source.zip from release
    local source_url="https://github.com/$owner/$repo/archive/refs/tags/$tag.zip"
    
    echo "Downloading source from: $source_url"
    
    if curl -s -L -o "$zip_file" "$source_url"; then
        # Extract the zip file
        # echo "üì¶ Extracting source..."
        if unzip -q "$zip_file"; then
            # echo "‚úÖ Source extracted successfully"
            
            # Find the extracted directory (should be repo-tag)
            local extracted_dir=$(find . -maxdepth 1 -type d -name "*$tag" | head -1)
            if [ -n "$extracted_dir" ]; then
                mv "$extracted_dir" "$expected_dir"
                # echo "‚úÖ Source organized as $expected_dir/"
            else
                echo "‚ö†Ô∏è Could not find expected extracted directory"
            fi
            
            # Clean up zip file
            rm -f "$zip_file"
        else
            rm -f "$zip_file"  # remove zip immediately after successful extraction
            echo "‚ùå Failed to extract source"
            return 1
        fi
    else
        echo "‚ùå Failed to fetch the release"
        exit 1
    fi
}

# Function to download binaries from GitHub release
download_binaries_from_release() {
    local owner="$1"
    local repo="$2"
    local tag="$3"
    local lib_dir="$4"    
    # Create lib directory structure
    local binary_dir="$lib_dir/$tag"
    rm -rf "$binary_dir"
    mkdir -p "$binary_dir"
    
    # Get release assets via GitHub API
    local api_url="https://api.github.com/repos/$owner/$repo/releases/tags/$tag"
    
    echo "Fetching release assets from GitHub..."
    
    # Download only .so and .a assets
    local assets=$(curl -s "$api_url" | jq -r '.assets[].browser_download_url' 2>/dev/null \
        | grep -E '\.(so|a)$')
    
    if [ -z "$assets" ]; then
        echo "‚ùå No .so or .a assets found in release or failed to fetch release info"
        return 1
    fi
    
    # echo "Found $(echo "$assets" | wc -l) assets to download"
    
    # Download each asset
    echo "$assets" | while read -r asset_url; do
        if [ -n "$asset_url" ]; then
            local filename=$(basename "$asset_url")
            local asset_dir="$binary_dir/${filename%.*}"  # Remove extension for folder name
            
            # echo "üì¶ Downloading: $filename"
            
            mkdir -p "$asset_dir"
            
            if curl -s -L -o "$asset_dir/$filename" "$asset_url"; then
                # echo "‚úÖ Downloaded: $filename -> $asset_dir/"
                :
            else
                echo "‚ùå Failed to download: $filename"
            fi
        fi
    done
    
    # echo "‚úÖ All binaries downloaded to $binary_dir/"
    echo "‚úÖ Assets downloaded successfully"

}

parse_with_bash_regex() {
    local repo="$1"
    local tag="${2:-$repo}"   # if $2 is empty, use $repo as fallback

    # Handle both possible filenames
    local input_file="src/$repo/.github/workflows/precompiled_binaries.yml"
    [[ ! -f "$input_file" ]] && input_file="src/$repo/.github/workflows/precompile_binaries.yml"

    if [[ ! -f "$input_file" ]]; then
        echo "‚ùå No precompiled/precompile_binaries.yml found for $repo"
        return 1
    fi

    # Flatten file into one line for regex scanning
    local content
    content=$(tr '\n' ' ' < "$input_file")

    # Extract values
    [[ $content =~ --android-ndk-version=([^[:space:]]+) ]] && ndk_version="${BASH_REMATCH[1]}"
    [[ $content =~ --android-sdk-location=([^[:space:]]+) ]] && sdk_location="${BASH_REMATCH[1]}"
    [[ $content =~ --android-min-sdk-version=([^[:space:]]+) ]] && min_sdk_version="${BASH_REMATCH[1]}"
    [[ $content =~ --tempdir=([^[:space:]]+) ]] && tempdir="${BASH_REMATCH[1]}"

    # Write env file (suffix = tag)
    local env_file=".env_build_$tag"
    cat > "$env_file" << EOF
NDK_VERSION=$ndk_version
SDK_LOCATION=$sdk_location
MIN_SDK_VERSION=$min_sdk_version
TEMPDIR=$tempdir
EOF

    echo "‚úÖ Created $env_file from $input_file"
}



# Function to update TEMPDIR keys in .env_build_$tag
update_tempdir_keys() {
  local tag="$1"
  local repo="$2"
  local env_file=".env_build_${tag}"
  local build_info="build-info.env"
  local key="TEMPDIR"
  local key_macos="TEMPDIR-MACOS"
  local key_linux="TEMPDIR-LINUX"
  local repo_upper
  repo_upper=$(echo "$repo" | tr '[:lower:]' '[:upper:]')

  # Get the value of TEMPDIR in .env_build_$tag
  local tempdir_val
  tempdir_val=$(grep "^${key}=" "$env_file" | cut -d'=' -f2-)

  if [ -z "$tempdir_val" ]; then
    # Remove TEMPDIR line
    sed -i '' "/^${key}=/d" "$env_file"

    # Get values from build-info.env
    local macos_val linux_val
    macos_val=$(grep "^${repo_upper}_TEMP_DIR_MACOS=" "$build_info" | cut -d'=' -f2-)
    linux_val=$(grep "^${repo_upper}_TEMP_DIR_LINUX=" "$build_info" | cut -d'=' -f2-)

    # Add new keys
    echo "${key_macos}=${macos_val}" >> "$env_file"
    echo "${key_linux}=${linux_val}" >> "$env_file"
  fi
}

## Allow cargokit to use any rust version as toolchain
replace_cargo_build_options() {
  local repo="$1"
  local file="src/$repo/cargokit/build_tool/lib/src/options.dart"

  if [[ ! -f "$file" ]]; then
    echo "‚ùå File not found: $file" >&2
    return 1
  fi

  local tmpfile
  tmpfile=$(mktemp)

  cat > "$tmpfile" <<'EOF'
class CargoBuildOptions {
  /// Can be 'stable', 'beta', 'nightly', or any custom string like '1.77.0'.
  final String toolchain;
  final List<String> flags;

  CargoBuildOptions({
    required this.toolchain,
    required this.flags,
  });

  /// Reads the toolchain string from a YAML node.
  static String _toolchainFromNode(YamlNode node) {
    if (node case YamlScalar(value: String name)) {
      return name; // just return the string directly
    }
    throw SourceSpanException(
      'Toolchain must be a string (e.g., "stable", "beta", "nightly", or a version like "1.77.0").',
      node.span,
    );
  }

  static CargoBuildOptions parse(YamlNode node) {
    if (node is! YamlMap) {
      throw SourceSpanException('Cargo options must be a map', node.span);
    }

    String toolchain = "stable"; // default
    List<String> flags = [];

    for (final MapEntry(:key, :value) in node.nodes.entries) {
      if (key case YamlScalar(value: 'toolchain')) {
        toolchain = _toolchainFromNode(value);
      } else if (key case YamlScalar(value: 'extra_flags')) {
        if (value case YamlList(nodes: List<YamlNode> list)) {
          if (list.every((element) => element is YamlScalar<String>)) {
            flags = list.map((e) => (e as YamlScalar).value as String).toList();
            continue;
          }
        }
        throw SourceSpanException(
          'Extra flags must be a list of strings',
          value.span,
        );
      } else {
        throw SourceSpanException(
          'Unknown cargo option type. Must be "toolchain" or "extra_flags".',
          key.span,
        );
      }
    }

    return CargoBuildOptions(toolchain: toolchain, flags: flags);
  }
}
EOF

  # Use awk to replace between lines (works on macOS and Linux)
  awk -v replfile="$tmpfile" '
    BEGIN {while((getline line < replfile)>0) repl = repl line "\n"}
    /class CargoBuildOptions {/ {print repl; skip=1; next}
    skip && /^}/ {skip=0; next}
    !skip {print}
  ' "$file" > "${file}.tmp" && mv "${file}.tmp" "$file"

  rm -f "$tmpfile"

  echo "‚úÖ Replaced CargoBuildOptions in $file"
}
# Function to parse Rust toolchain from a .so file
parse_rust_toolchain_from_linux_so() {
  local base_dir="${1:-.}"
  local tag="${2:-}"
  local env_file=".env_build_${tag}"

  # Find the first .so file in any subdirectory
  local so_file
  so_file=$(find "$base_dir" -type f -name "*.so" | head -n1)
  [ -z "$so_file" ] && echo "No .so file found in $base_dir" >&2 && return 1

  local toolchain
  toolchain=$(strings "$so_file" | grep -oE 'rustc version [^ ]+ \([^)]+\)' | head -n1 | \
    sed -E \
      -e 's/rustc version ([0-9]+\.[0-9]+\.[0-9]+)-nightly \([a-f0-9]+ ([0-9]{4}-[0-9]{2}-[0-9]{2})\)/nightly-\2/' \
      -e 's/rustc version ([0-9]+\.[0-9]+\.[0-9]+)-beta \([a-f0-9]+ ([0-9]{4}-[0-9]{2}-[0-9]{2})\)/beta-\2/' \
      -e 's/rustc version ([0-9]+\.[0-9]+\.[0-9]+) \([^)]+\)/\1/'
  )

  [ -z "$toolchain" ] && echo "No rustc version found in $so_file" >&2 && return 1

  # Add or update RUST_VERSION in env file if tag is provided
  if [ -n "$tag" ]; then
    if grep -q '^RUST_VERSION=' "$env_file" 2>/dev/null; then
      sed -i '' "s|^RUST_VERSION=.*|RUST_VERSION=$toolchain|" "$env_file"
    else
      echo "RUST_VERSION=$toolchain" >> "$env_file"
    fi
  fi

  echo "$toolchain"
}

parse_xcode_version_from_macos_lib() {
  local base_dir="${1:-.}"
  local tag="${2:-}"
  local env_file=".env_build_${tag}"

  # Find the first .a file in any subdirectory
  local lib_file
  lib_file=$(find "$base_dir" -type f -name "*.a" | head -n1)
  [ -z "$lib_file" ] && echo "No .a file found in $base_dir" >&2 && return 1

  local xcode_version
  xcode_version=$(strings "$lib_file" | grep -oE '/Applications/Xcode_[0-9]+\.[0-9]+' | \
    sed -E 's#.*/Xcode_([0-9]+\.[0-9]+).*#\1#' | head -n1)

  [ -z "$xcode_version" ] && echo "No Xcode version found in $lib_file" >&2 && return 1

  # Add or update XCODE_VERSION in env file if tag is provided
  if [ -n "$tag" ]; then
    if grep -q '^XCODE_VERSION=' "$env_file" 2>/dev/null; then
      sed -i '' "s|^XCODE_VERSION=.*|XCODE_VERSION=$xcode_version|" "$env_file"
    else
      echo "XCODE_VERSION=$xcode_version" >> "$env_file"
    fi
  fi

  echo "$xcode_version"
}

update_cargokit_toolchain() {
  local env_file="$1"
  local repo="$2"
  local cargokit_file="src/$repo/rust/cargokit.yaml"
  local options_file="src/$repo/cargokit_options.yaml"

  # Extract RUST_VERSION from env file
  local rust_version
  rust_version=$(grep '^RUST_VERSION=' "$env_file" | cut -d'=' -f2-)
  if [ -z "$rust_version" ]; then
    echo "‚ùå RUST_VERSION not found in $env_file"
    return 1
  fi

  # Update toolchain in cargokit.yml (release section only, no quotes)
  sed -i '' -E "s|^([[:space:]]*toolchain:).*|\1 $rust_version|" "$cargokit_file"
  echo "‚úÖ Updated release toolchain in $cargokit_file to $rust_version"

  # Handle cargokit_options.yaml
  if [ -f "$options_file" ]; then
    if grep -q '^use_precompiled_binaries:' "$options_file"; then
      sed -i '' -E 's|^use_precompiled_binaries:.*|use_precompiled_binaries: false|' "$options_file"
      echo "‚úÖ Set use_precompiled_binaries: false in $options_file"
    else
      echo "use_precompiled_binaries: false" >> "$options_file"
      echo "‚úÖ Added use_precompiled_binaries: false to $options_file"
    fi
  else
    echo "use_precompiled_binaries: false" > "$options_file"
    echo "‚úÖ Created $options_file with use_precompiled_binaries: false"
  fi
}

update_cargo_config() {
  local repo="$1"
  local config_file="configs/${repo}-config.toml"
  local dest_dir="src/$repo/rust/.cargo"
  local dest_file="$dest_dir/config.toml"

  # Check if config exists
  if [ ! -f "$config_file" ]; then
    echo "‚ùå Config file $config_file not found"
    return 1
  fi

  # Ensure destination directory exists
  mkdir -p "$dest_dir"

  # Copy config
  cp "$config_file" "$dest_file"

  echo "‚úÖ Updated Cargo config for $repo ‚Üí $dest_file"
}



bdkcross__build() {
    library_or_url=$1 
    
    # Check if library or URL was passed
    if [ -z "$1" ]; then
        echo "‚ùå You did not specify a GitHub release URL! ‚ùå"
        usage=" 
        USAGE
            $ ./bdk-cross build <github-release-url>

        EXAMPLE 
            $ ./bdk-cross build https://github.com/LtbLightning/bdk-flutter/releases/tag/precompiled_ddbd7c3e656f85af25bbb5932e2a731e"
        echo "$usage"
        exit 1 
    fi

    # Check if it's a GitHub release URL
    if [[ "$library_or_url" == https://github.com/*/releases/tag/* ]]; then
        # echo "üîó Found GitHub release URL: $library_or_url"
        
        # Parse the URL
        local parsed=$(parse_github_release_url "$library_or_url")
        if [ $? -ne 0 ]; then
            echo "‚ùå $parsed"
            exit 1
        fi
        
        IFS=':' read -r owner repo tag <<< "$parsed"
        echo "üìã Parsed: Owner=$owner, Repo=$repo, Tag=$tag"
        
        # Set up directories
        local src_dir="$(pwd)/src"
        local lib_dir="$(pwd)/lib/$repo"
        
        # Download source
        download_source_from_release "$owner" "$repo" "$tag" "$src_dir"
        
        # Download binaries
        download_binaries_from_release "$owner" "$repo" "$tag" "$lib_dir"
        
        # echo "‚úÖ Setup complete!"
        # echo " Source: $src_dir/$repo/"
        # echo " Binaries: $lib_dir/$tag/"
        
        # Set library name for further processing
        library="$repo"
        VERSION="$tag"
        cd ../
       
        parse_with_bash_regex $repo $tag
        replace_cargo_build_options $repo
        update_tempdir_keys $tag $repo
        parse_rust_toolchain_from_linux_so "lib/$tag" "$tag" || {
            echo "‚ùå Failed to parse Rust toolchain version"
            exit 1
        }
        parse_xcode_version_from_macos_lib "lib/$tag" "$tag" || {
            echo "‚ùå Failed to parse Xcode version"
            exit 1
        }
        update_cargokit_toolchain ".env_build_$tag" "$repo" || {
            echo "‚ùå Failed to update Cargokit toolchain"
            exit 1
        }
        update_cargo_config "$repo" || {
            echo "‚ùå Failed to update Cargo config"
            exit 1
        }
        ## ‚úÖ1 Set temp dir from build info if it doesn't exist or is set in env, set the library being build/compiled
        ## ‚úÖ2 Parse rust version set in .env and also in cargokit.yaml, and set precompiled to false
        ## ‚úÖ3 Get the Xcode version used and set it in .env
        ## ‚úÖ 5 Update patched cargo_kit version that allows varied rust version
        ## 6 Set the correct .cargo.config.toml settings
        ## 7 Rename Xcode path
        echo "üîÑ Building all targets for $library release $tag"

        # Get all build script files and run them
        # echo "üîÑ Running all build scripts..."
        
        # Get all .sh files in build-scripts directory
        for script in build-scripts/*.sh; do
            if [ -f "$script" ]; then
                script_name=$(basename "$script" .sh)
                echo "üü° Starting $script_name build"
            . ./configs.sh
                . "$script" "$library" "$VERSION"
            fi
        done
        
        echo "‚úÖ All builds completed!"
        #5 remove .env_build_$tag
        
    else
        echo "‚ùå Please provide a valid GitHub release URL"
        echo "Example: https://github.com/LtbLightning/bdk-flutter/releases/tag/precompiled_ddbd7c3e656f85af25bbb5932e2a731e"
            exit 1
    fi
}

bdkcross__help_build(){

    help="
    Build binaries for all targets from GitHub release
    USAGE
        $ ./bdk-cross build <github-release-url>

    EXAMPLE 
        $ ./bdk-cross build https://github.com/LtbLightning/bdk-flutter/releases/tag/precompiled_ddbd7c3e656f85af25bbb5932e2a731e
    "

    echo "$help"

}


bdkcross__verify(){
    library_or_url=$1
    
    # Check if library or URL was passed
    if [ -z "$1" ]; then
        echo "‚ùå You did not specify a GitHub release URL! ‚ùå"
        usage=" 
        USAGE
            $ ./bdk-cross verify <github-release-url>

        EXAMPLE 
            $ ./bdk-cross verify https://github.com/LtbLightning/bdk-flutter/releases/tag/precompiled_ddbd7c3e656f85af25bbb5932e2a731e"
        echo "$usage"
        exit 1 
    fi

    # Check if it's a GitHub release URL
    if [[ "$library_or_url" == https://github.com/*/releases/tag/* ]]; then
        echo "üîó Detected GitHub release URL: $library_or_url"
        
        # Parse the URL
        local parsed=$(parse_github_release_url "$library_or_url")
        if [ $? -ne 0 ]; then
            echo "‚ùå $parsed"
            exit 1
        fi
        
        IFS=':' read -r owner repo tag <<< "$parsed"
        echo "üìã Parsed: Owner=$owner, Repo=$repo, Tag=$tag"
        
        # Set library name for verification
        library="$repo"
        VERSION="$tag"
        
        echo "üîÑ Verifying all targets for $library version $tag"

    cd src/$library/rust
    package_name_line=$(grep -m 1 -E '^name = .*' Cargo.toml)

    if [ ! -z "$package_name_line" ]; then
        package_name=$(echo "$package_name_line" | cut -d '=' -f2 | tr -d '[:space:]' | sed 's/^"//' | sed 's/"$//')
    else
        echo "Error: Could not find 'name' in [package] section"
        exit 1
    fi
    cd ../../../
        
        # Get all build script files and verify them
        echo "üîÑ Running all verification scripts..."
        
        # Get all .sh files in build-scripts directory
        for script in build-scripts/*.sh; do
            if [ -f "$script" ]; then
                script_name=$(basename "$script" .sh)
                echo "üü° Verifying $script_name"
                # For verification, we'll use the download_and_verify_library function
                # This would need to be adapted based on your verification logic
                echo "üü° Verification for $script_name completed"
            fi
        done
        
        echo "‚úÖ All verifications completed!"
        
    else
        echo "‚ùå Please provide a valid GitHub release URL"
        echo "Example: https://github.com/LtbLightning/bdk-flutter/releases/tag/precompiled_ddbd7c3e656f85af25bbb5932e2a731e"
        exit 1
    fi
}

bdkcross__help_verify() {
    help="
Verify a build for all targets from GitHub release

USAGE
$ ./bdk-cross verify <github-release-url>

EXAMPLE 
$ ./bdk-cross verify https://github.com/LtbLightning/bdk-flutter/releases/tag/precompiled_ddbd7c3e656f85af25bbb5932e2a731e
"

echo "$help"

}

# Add a new function for just downloading without building
bdkcross__download() {
    local library_or_url="$2"
    
    if [ -z "$library_or_url" ]; then
        echo "‚ùå You did not specify a library or GitHub release URL! ‚ùå"
        echo "Usage: $ ./bdk-cross download <github-release-url>"
        exit 1
    fi
    
    if [[ "$library_or_url" == https://github.com/*/releases/tag/* ]]; then
        echo "üîó Downloading from GitHub release URL: $library_or_url"
        
        # Parse the URL
        local parsed=$(parse_github_release_url "$library_or_url")
        if [ $? -ne 0 ]; then
            echo "‚ùå $parsed"
            exit 1
        fi
        
        IFS=':' read -r owner repo tag <<< "$parsed"
        echo "üìã Parsed: Owner=$owner, Repo=$repo, Tag=$tag"
        
        # Set up directories
        local src_dir="$(pwd)/src"
        local lib_dir="$(pwd)/lib"
        
        # Download source
        download_source_from_release "$owner" "$repo" "$tag" "$src_dir"
        
        # Download binaries
        download_binaries_from_release "$owner" "$repo" "$tag" "$lib_dir"
        
        echo "‚úÖ Download complete!"
        echo " Source: $src_dir/$repo/"
        echo " Binaries: $lib_dir/$tag/"
        
    else
        echo "‚ùå Please provide a valid GitHub release URL"
        echo "Example: https://github.com/LtbLightning/bdk-flutter/releases/tag/precompiled_ddbd7c3e656f85af25bbb5932e2a731e"
        exit 1
    fi
}

bdkcross__help_download() {
    help="
    Download source and binaries from GitHub release
    USAGE
        $ ./bdk-cross download <github-release-url>

    EXAMPLE 
        $ ./bdk-cross download https://github.com/LtbLightning/bdk-flutter/releases/tag/precompiled_ddbd7c3e656f85af25bbb5932e2a731e
    "
    echo "$help"
}



bdkcross__help(){

    if [ $# -eq 2 ]; then
      call "bdkcross__$1_$2" "$@"
      exit 0
    fi

    help="

 ____  ____  _  __     ____  _____ ____       ____  _   _ ___ _     ____  
| __ )|  _ \| |/ /    |  _ \| ____|  _ \     | __ )| | | |_ _| |   |  _ \ 
|  _ \| | | | ' /_____| |_) |  _| | |_) |____|  _ \| | | || || |   | | | |
| |_) | |_| | . \_____|  _ <| |___|  __/_____| |_) | |_| || || |___| |_| |
|____/|____/|_|\_\    |_| \_\_____|_|        |____/ \___/|___|_____|____/ 

        Cross-compile and verify reproducible builds for bdk-rust library.
            * To use with : BDK-Flutter, LWK-Dart, BOLTZ-dart
            * Targeting: Linux, Android, iOS, macOS 
            * Now supports GitHub release URLs for direct download and build
USAGE
    $ bdk-cross [COMMAND]
    $ bdk-cross help [COMMAND]

COMMANDS
    help                show help
    download            download source and binaries from GitHub release
    verify              verify build against release
    build               build artifacts for all targets from GitHub release     

EXAMPLES
    $ ./bdk-cross build https://github.com/LtbLightning/bdk-flutter/releases/tag/precompiled_ddbd7c3e656f85af25bbb5932e2a731e
    $ ./bdk-cross verify https://github.com/LtbLightning/bdk-flutter/releases/tag/precompiled_ddbd7c3e656f85af25bbb5932e2a731e
    $ ./bdk-cross download https://github.com/LtbLightning/bdk-flutter/releases/tag/precompiled_ddbd7c3e656f85af25bbb5932e2a731e     

"

echo "$help"

}

call() {
    func=$1
    if type "$func" 1>/dev/null 2>&1; then
        # if it's bdk_rep_build COMMAND help, then call help for that command
        case $3 in
          -h|--help|help)
          call "bdkcross__help_$2"
          exit 0
          ;;
        esac
        shift # remove func from args
        shift # remove command name from args
        "$func" "$@"  # invoke our named function w/ all remaining arguments
    else
        # if it's bdk_rep_build -h COMMAND, then call help for that command
        case $2 in
          -h|--help)
          call "bdkcross__help_$3"
          exit 0
          ;;
        esac
        bdkcross__help
        exit 1
    fi
}

call "bdkcross__$1" "$@"